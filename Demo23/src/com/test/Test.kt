package com.test

/**
 *
 *
 * 使用高阶函数会带来一些运行时的效率损失：每一个函数都是一个对象，并且会捕获一个闭包。
 *
 * 即那些在函数体内会访问到的变量。 内存分配（对于函数对象和类）和虚拟调用会引入运行时间开销。
 *
 * 但是在许多情况下通过内联化 lambda 表达式可以消除这类的开销。 下述函数是这种情况的很好的例子。即 lock() 函数可以很容易地在调用处内联。 考虑下面的情况：
 *
 * inline 修饰符影响函数本身和传给它的 lambda 表达式：所有这些都将内联到调用处。
 *
 * 如果你只想被（作为参数）传给一个内联函数的 lambda 表达式中只有一些被内联，你可以用 noinline 修饰符标记一些函数参数：
 *
 * 可以内联的 lambda 表达式只能在内联函数内部调用或者作为可内联的参数传递，
 *
 * 但是 noinline 的可以以任何我们喜欢的方式操作：存储在字段中、传送它等等。
 *
 * 需要注意的是，如果一个内联函数没有可内联的函数参数并且没有具体化的类型参数，
 *
 * 编译器会产生一个警告，因为内联这样的函数很可能并无益处（如果你确认需要内联，则可以用 @Suppress("NOTHING_TO_INLINE") 注解关掉该警告）。
 */
inline fun foo(inlined: () -> Unit, noinline notInlined: () -> Unit) {}

inline fun test(){}

fun main(args:Array<String>){
    test()
}